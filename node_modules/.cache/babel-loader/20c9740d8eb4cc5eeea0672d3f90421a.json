{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], t) : (e = e || self).ReactSlideToggle = t(e.React);\n}(this, function (e) {\n  \"use strict\";\n\n  function t(e, t) {\n    for (var a = 0; a < t.length; a++) {\n      var s = t[a];\n      s.enumerable = s.enumerable || !1, s.configurable = !0, \"value\" in s && (s.writable = !0), Object.defineProperty(e, s.key, s);\n    }\n  }\n\n  function a(e, t, a) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: a,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = a, e;\n  }\n\n  function s(e) {\n    return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function o(e, t) {\n    return (o = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function n(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n\n  e = e && e.hasOwnProperty(\"default\") ? e.default : e;\n\n  var r = \"undefined\" != typeof window ? window : global,\n      l = r.requestAnimationFrame ? r.requestAnimationFrame.bind(r) : function (e) {\n    return r.setTimeout(e, 16);\n  },\n      i = r.cancelAnimationFrame ? r.cancelAnimationFrame.bind(r) : r.clearInterval.bind(r),\n      p = Object.freeze({\n    EXPANDED: \"EXPANDED\",\n    COLLAPSED: \"COLLAPSED\",\n    EXPANDING: \"EXPANDING\",\n    COLLAPSING: \"COLLAPSING\"\n  }),\n      g = function (e) {\n    return e < .5 ? 4 * e * e * e : .5 * Math.pow(2 * e - 2, 3) + 1;\n  },\n      u = {\n    isMoving: function (e) {\n      return e === p.EXPANDING || e === p.COLLAPSING;\n    },\n    clamp: function (e) {\n      var t = e.value,\n          a = e.max,\n          s = void 0 === a ? 1 : a,\n          o = e.min,\n          n = void 0 === o ? 0 : o;\n      return t > s ? s : t < n ? n : t;\n    },\n    now: function () {\n      return Date.now();\n    },\n    sanitizeDuration: function (e) {\n      return Math.max(0, parseInt(+e, 10) || 0);\n    },\n    interpolate: function (e) {\n      var t = e.next,\n          a = e.prev,\n          s = Math.abs(t - a),\n          o = t;\n      return s > .15 && (t > a ? o -= .75 * s : o += .75 * s), o;\n    }\n  },\n      c = function (e) {\n    function r() {\n      var e, t;\n      !function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, r);\n\n      for (var o = arguments.length, i = new Array(o), g = 0; g < o; g++) i[g] = arguments[g];\n\n      return t = function (e, t) {\n        return !t || \"object\" != typeof t && \"function\" != typeof t ? n(e) : t;\n      }(this, (e = s(r)).call.apply(e, [this].concat(i))), a(n(t), \"_state_\", {\n        collapsibleElement: null,\n        toggleState: t.props.collapsed ? p.COLLAPSED : p.EXPANDED\n      }), a(n(t), \"GET_HEIGHT\", t.props.offsetHeight ? \"offsetHeight\" : \"scrollHeight\"), a(n(t), \"state\", {\n        toggleState: t._state_.toggleState,\n        hasReversed: !1,\n        range: t.props.collapsed ? 0 : 1,\n        progress: t.props.collapsed ? 0 : 1\n      }), a(n(t), \"getCollapsible\", function () {\n        return t._state_.collapsibleElement;\n      }), a(n(t), \"updateCollapsible\", function (e, a) {\n        t.getCollapsible() && (t._state_.collapsibleElement.style[e] = a);\n      }), a(n(t), \"setCollapsibleElement\", function (e) {\n        t._state_.collapsibleElement = e, t._state_.collapsibleElement && (t._state_.collapsibleElement.style.overflow = \"hidden\"), t._state_.toggleState === p.COLLAPSED && t.setCollapsedState({\n          initialState: !0\n        });\n      }), a(n(t), \"toggle\", function () {\n        if (!t.props.irreversible || !u.isMoving(t._state_.toggleState)) {\n          var e = function () {\n            t.props.onCollapsing && t.props.onCollapsing({\n              range: t.state.range,\n              progress: t.state.progress,\n              hasReversed: t.state.hasReversed\n            }), t.collapse();\n          },\n              a = function () {\n            t.props.onExpanding && t.props.onExpanding({\n              range: t.state.range,\n              progress: t.state.progress,\n              hasReversed: t.state.hasReversed\n            }), t.expand();\n          },\n              s = function (e) {\n            var a = e.toggleState,\n                s = e.display,\n                o = e.hasReversed;\n            t._state_.toggleState = a, t._state_.hasReversed = !!o, void 0 === s || t.props.noDisplayStyle || t.updateCollapsible(\"display\", s);\n            var n = u.now();\n\n            if (o) {\n              var r = t._state_.startTime,\n                  l = u.sanitizeDuration(t.props.duration),\n                  i = Math.min(l, n - r),\n                  p = Math.max(0, l - i);\n              t._state_.startTime = n - p;\n            } else {\n              var g = t.getCollapsible();\n              g && g.style.height && t.updateCollapsible(\"height\", null), t._state_.boxHeight = g ? g[t.GET_HEIGHT] : 0, t._state_.startTime = n, t._state_.startDirection = a;\n            }\n\n            t.setState({\n              toggleState: t._state_.toggleState,\n              hasReversed: t._state_.hasReversed\n            });\n          };\n\n          switch (t._state_.toggleState) {\n            case p.EXPANDED:\n              s({\n                toggleState: p.COLLAPSING\n              }), e();\n              break;\n\n            case p.COLLAPSED:\n              s({\n                toggleState: p.EXPANDING,\n                display: \"\"\n              }), a();\n              break;\n\n            case p.EXPANDING:\n              s({\n                toggleState: p.COLLAPSING,\n                hasReversed: !0\n              }), e();\n              break;\n\n            case p.COLLAPSING:\n              s({\n                toggleState: p.EXPANDING,\n                display: \"\",\n                hasReversed: !0\n              }), a();\n          }\n        }\n      }), a(n(t), \"setExpandedState\", function () {\n        t._state_.progress = 1, t._state_.toggleState = p.EXPANDED, t.updateCollapsible(\"height\", null), t.setState({\n          toggleState: p.EXPANDED,\n          range: 1,\n          progress: t._state_.progress\n        }), t.props.onExpanded && t.props.onExpanded({\n          hasReversed: t.state.hasReversed\n        });\n      }), a(n(t), \"expand\", function () {\n        if (t._state_.toggleState === p.EXPANDING) {\n          var e = u.sanitizeDuration(t.props.duration);\n          if (e <= 0) t.setExpandedState();else {\n            var a = t._state_.startTime,\n                s = Math.min(e, u.now() - a);\n            if (s >= e) t.setExpandedState();else {\n              var o,\n                  n = t._state_,\n                  r = n.startDirection,\n                  l = n.toggleState,\n                  i = n.boxHeight,\n                  g = u.clamp({\n                value: s / e\n              });\n              o = t.props.whenReversedUseBackwardEase && r !== l ? 1 - t.props.easeCollapse(1 - g) : t.props.easeExpand(g), t.props.bestPerformance || t.setState({\n                range: g,\n                progress: o\n              }), t.props.interpolateOnReverse && t._state_.hasReversed && (o = u.interpolate({\n                next: o,\n                prev: t._state_.progress\n              }));\n              var c = Math.round(i * o);\n              t._state_.progress = o, t.updateCollapsible(\"height\", \"\".concat(c, \"px\")), t.nextTick(t.expand);\n            }\n          }\n        }\n      }), a(n(t), \"setCollapsedState\", function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            a = e.initialState;\n        t._state_.progress = 0, t._state_.toggleState = p.COLLAPSED, t.props.noDisplayStyle ? t.updateCollapsible(\"height\", \"0px\") : (t.updateCollapsible(\"display\", \"none\"), t.updateCollapsible(\"height\", null)), t.setState({\n          toggleState: p.COLLAPSED,\n          range: 0,\n          progress: t._state_.progress\n        }), !a && t.props.onCollapsed && t.props.onCollapsed({\n          hasReversed: t.state.hasReversed\n        });\n      }), a(n(t), \"collapse\", function () {\n        if (t._state_.toggleState === p.COLLAPSING) {\n          var e = u.sanitizeDuration(t.props.duration);\n          if (e <= 0) t.setCollapsedState();else {\n            var a = t._state_.startTime,\n                s = Math.min(e, u.now() - a);\n            if (s >= e) t.setCollapsedState();else {\n              var o,\n                  n = t._state_,\n                  r = n.startDirection,\n                  l = n.boxHeight,\n                  i = n.toggleState,\n                  g = 1 - u.clamp({\n                value: s / e\n              }),\n                  c = t.props,\n                  d = c.whenReversedUseBackwardEase,\n                  h = c.easeExpand,\n                  _ = c.easeCollapse;\n              o = d && r !== i ? h(g) : 1 - _(1 - g), t.props.bestPerformance || t.setState({\n                range: g,\n                progress: o\n              }), t.props.interpolateOnReverse && t._state_.hasReversed && (o = u.interpolate({\n                next: o,\n                prev: t._state_.progress\n              }));\n              var f = Math.round(l * o);\n              t._state_.progress = o, t._state_.timeout = t.nextTick(t.collapse), t.updateCollapsible(\"height\", \"\".concat(f, \"px\"));\n            }\n          }\n        }\n      }), a(n(t), \"nextTick\", function (e) {\n        t._state_.timeout = l(e);\n      }), t;\n    }\n\n    var g, c, d;\n    return function (e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && o(e, t);\n    }(r, e), g = r, (c = [{\n      key: \"render\",\n      value: function () {\n        var e = {\n          onToggle: this.toggle,\n          toggle: this.toggle,\n          setCollapsibleElement: this.setCollapsibleElement,\n          toggleState: this.state.toggleState,\n          hasReversed: this.state.hasReversed,\n          isMoving: u.isMoving(this.state.toggleState),\n          range: this.state.range,\n          progress: this.state.progress\n        };\n        return \"function\" == typeof this.props.children ? this.props.children(e) : this.props.render ? this.props.render(e) : this.props.children;\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function () {\n        this.props.onMount && this.props.onMount({\n          toggleState: this.state.toggleState,\n          toggle: this.toggle\n        });\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function (e, t) {\n        this.props.collapseEvent && this.props.collapseEvent > e.collapseEvent && (this._state_.toggleState !== p.EXPANDED && this._state_.toggleState !== p.EXPANDING || this.toggle()), this.props.expandEvent && this.props.expandEvent > e.expandEvent && (this._state_.toggleState !== p.COLLAPSED && this._state_.toggleState !== p.COLLAPSING || this.toggle()), this.props.toggleEvent && this.props.toggleEvent > e.toggleEvent && this.toggle();\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function () {\n        this.props.onUnmount && this.props.onUnmount({\n          toggleState: this.state.toggleState\n        }), this._state_.timeout && i(this._state_.timeout);\n      }\n    }]) && t(g.prototype, c), d && t(g, d), r;\n  }(e.Component);\n\n  return a(c, \"defaultProps\", {\n    duration: 300,\n    easeCollapse: g,\n    easeExpand: g\n  }), c;\n});","map":null,"metadata":{},"sourceType":"script"}